// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, eaddress, externalEaddress} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title ShadowStorage
/// @notice Stores encrypted references to user files on-chain.
contract ShadowStorage is ZamaEthereumConfig {
    struct FileRecord {
        string fileName;
        string encryptedIpfsHash;
        eaddress encryptedSecret;
        uint256 createdAt;
    }

    mapping(address => FileRecord[]) private _filesByOwner;

    event FileStored(address indexed owner, uint256 indexed index, string fileName, string encryptedIpfsHash);
    event FileAccessGranted(address indexed owner, address indexed grantee, uint256 indexed index);

    /// @notice Stores an encrypted file reference for the caller.
    /// @param fileName Human readable file name.
    /// @param encryptedIpfsHash Symmetric encryption of the IPFS hash produced off-chain.
    /// @param encryptedSecretHandle Handle for the encrypted random wallet address A.
    /// @param inputProof Proof generated by the relayer for the encrypted input.
    function saveFile(
        string calldata fileName,
        string calldata encryptedIpfsHash,
        externalEaddress encryptedSecretHandle,
        bytes calldata inputProof
    ) external {
        if (bytes(fileName).length == 0) {
            revert("EMPTY_NAME");
        }
        if (bytes(encryptedIpfsHash).length == 0) {
            revert("EMPTY_HASH");
        }

        eaddress encryptedSecret = FHE.fromExternal(encryptedSecretHandle, inputProof);

        FileRecord memory record = FileRecord({
            fileName: fileName,
            encryptedIpfsHash: encryptedIpfsHash,
            encryptedSecret: encryptedSecret,
            createdAt: block.timestamp
        });

        _filesByOwner[msg.sender].push(record);

        FHE.allowThis(encryptedSecret);
        FHE.allow(encryptedSecret, msg.sender);

        emit FileStored(msg.sender, _filesByOwner[msg.sender].length - 1, fileName, encryptedIpfsHash);
    }

    /// @notice Returns the number of stored files for a given user.
    function getFileCount(address user) external view returns (uint256) {
        return _filesByOwner[user].length;
    }

    /// @notice Returns a single file record for the provided user and index.
    function getFile(address user, uint256 index) external view returns (FileRecord memory) {
        FileRecord[] storage records = _filesByOwner[user];
        if (index >= records.length) {
            revert("INVALID_INDEX");
        }
        return records[index];
    }

    /// @notice Returns all stored file records for a given user.
    function getFiles(address user) external view returns (FileRecord[] memory) {
        FileRecord[] storage stored = _filesByOwner[user];
        FileRecord[] memory output = new FileRecord[](stored.length);
        for (uint256 i = 0; i < stored.length; i++) {
            output[i] = stored[i];
        }
        return output;
    }

    /// @notice Allows the caller to grant another account decryption rights for a stored entry.
    /// @param index Record index owned by the caller.
    /// @param account Address that should be allowed to decrypt the stored secret.
    function grantDecryptPermission(uint256 index, address account) external {
        if (account == address(0)) {
            revert("INVALID_ACCOUNT");
        }
        FileRecord[] storage records = _filesByOwner[msg.sender];
        if (index >= records.length) {
            revert("INVALID_INDEX");
        }

        FHE.allow(records[index].encryptedSecret, account);
        emit FileAccessGranted(msg.sender, account, index);
    }
}
